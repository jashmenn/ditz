#!/usr/bin/env ruby

## requires are split in two for efficiency reasons: ditz should be really
## fast when using it for completion.
require 'operator'
op = Ditz::Operator.new

## a secret option for shell completion
if ARGV.include? '--commands'
  puts op.class.operations.map { |name, _| name }
  exit 0
end

require 'rubygems'
require 'fileutils'
require 'pathname'
require 'trollop'; include Trollop
require "ditz"

PROJECT_FN = "project.yaml"
CONFIG_FN = ".ditz-config"

## helper for recursive search
def find_dir_containing target, start=Pathname.new(".")
  return start if (start + target).exist?
  unless start.parent.realpath == start.realpath
    find_dir_containing target, start.parent
  end
end

## this is my brilliant solution to the 'gem datadir' problem.
def find_ditz_file fn
  dir = $:.find { |p| File.exist? File.expand_path(File.join(p, fn)) }
  raise "can't find #{fn} in any load path" unless dir
  File.expand_path File.join(dir, fn)
end

$opts = options do
  version "ditz #{Ditz::VERSION}"
  opt :issue_dir, "Issue database dir", :default => "bugs"
  opt :config_file, "Configuration file", :default => File.join(ENV["HOME"], CONFIG_FN)
  opt :verbose, "Verbose output", :default => false
  opt :no_comment, "Skip asking for a comment", :default => false
  opt :list_hooks, "List all hooks and descriptions, and quit.", :short => 'l', :default => false
end

Ditz::HookManager.register :startup, <<EOS
Executes at startup

Variables: project, config
No return value.
EOS

Ditz::HookManager.register :after_add, <<EOS
Executes before terminating if new issue files has been created.
Basically you want to instruct your SCM that these files has
been added.

Variables: project, config, issues
No return value.
EOS

Ditz::HookManager.register :after_delete, <<EOS
Executes before terminating if new issue files has been deleted.
Basically you want to instruct your SCM that these files has
been deleted.

Variables: project, config, issues
No return value.
EOS

Ditz::HookManager.register :after_update, <<EOS
Executes before terminating if new issue files has been updated.
You may want to instruct your SCM about these changes.
Note that new issues are not considered updated.

Variables: project, config, issues
No return value.
EOS

if $opts[:list_hooks]
  Ditz::HookManager.print_hooks
  exit 0
end

local_config_dir = find_dir_containing CONFIG_FN
config = begin
  if local_config_dir
    fn = local_config_dir + CONFIG_FN
    Ditz::debug "loading local config from #{fn}"
    Ditz::Config.from fn
  else
    Ditz::debug "loading global config from #{$opts[:config_file]}"
    Ditz::Config.from $opts[:config_file]
  end
rescue SystemCallError, Ditz::ModelObject::ModelError => e
  puts <<EOS
I wasn't able to find a configuration file #{$opts[:config_file]}.
We'll set it up right now.
EOS
  Ditz::Config.create_interactively.save! $opts[:config_file]
end

config.plugins.each do |p|
  fn = find_ditz_file "plugins/#{p}.rb"
  Ditz::debug "loading plugin #{p.inspect} from #{fn}"
  load fn
end

cmd = ARGV.shift || "todo"
issue_dir = Pathname.new(config.issue_dir || $opts[:issue_dir])

case cmd # some special commands not handled by Ditz::Operator
when "init"
  die "#{issue_dir} directory already exists" if issue_dir.exist?
  issue_dir.mkdir
  fn = issue_dir + PROJECT_FN
  project = op.init
  project.save! fn
  puts "Ok, #{issue_dir} directory created successfully."
  exit
when "help"
  op.do "help", nil, nil, ARGV
  exit
end

project_root = find_dir_containing(issue_dir + PROJECT_FN)
die "No #{issue_dir} directory---use 'ditz init' to initialize" unless project_root
project_root += issue_dir

project = begin
  fn = project_root + PROJECT_FN
  Ditz::debug "loading project from #{fn}"
  project = Ditz::Project.from fn

  fn = project_root + "issue-*.yaml"
  Ditz::debug "loading issues from #{fn}"
  project.issues = Dir[fn].map { |fn| Ditz::Issue.from fn }
  Ditz::debug "found #{project.issues.size} issues"
  project
rescue SystemCallError, Ditz::Project::Error => e
  die "#{e.message} (use 'init' to initialize)"
end

project.validate!
project.issues.each { |p| p.project = project}
project.assign_issue_names!

unless op.has_operation? cmd
  die "no such command: #{cmd}"
end

Ditz::HookManager.run :startup, project, config

## talk about the law of unintended consequences. 'gets' requires this.
args = []
args << ARGV.shift until ARGV.empty?

Ditz::debug "executing command #{cmd}"
begin
  op.do cmd, project, config, args
rescue Ditz::Operator::Error => e
  die e.message
rescue Errno::EPIPE, Interrupt
  exit 1
end

## save project.yaml
dirty = project.each_modelobject { |o| break true if o.changed? } || false
if dirty
  fn = project_root + PROJECT_FN
  Ditz::debug "project is dirty, saving #{fn}"
  project.save! fn
end

## project issues are not model fields proper, so they must be
## saved independently.
changed_issues = project.issues.select { |i| i.changed? }
changed_issues.each do |i|
  i.pathname ||= (project_root + "issue-#{i.id}.yaml")
  i.project ||= project # hack: not set on new issues
  Ditz::debug "issue #{i.name} is dirty, saving #{i.pathname}"
  i.save! i.pathname
end

project.deleted_issues.each do |i|
  fn = i.pathname
  Ditz::debug "issue #{i.name} has been deleted, deleting #{fn}"
  FileUtils.rm fn
end

unless project.added_issues.empty?
  unless Ditz::HookManager.run :after_add, project, config, project.added_issues
    puts "You may have to inform your SCM that the following files have been added:"
    project.added_issues.each { |i| puts "  " + i.pathname }
  end
end

unless project.deleted_issues.empty?
  unless Ditz::HookManager.run :after_delete, project, config, project.deleted_issues
    puts "You may have to inform your SCM that the following files have been deleted:"
    project.deleted_issues.each { |i| puts "  " + i.pathname }
  end
end

changed_not_added_issues = changed_issues - project.added_issues
unless changed_not_added_issues.empty?
  Ditz::HookManager.run :after_update, project, config, changed_not_added_issues
end

config.save! $opts[:config_file] if config.changed?

# vim: syntax=ruby
